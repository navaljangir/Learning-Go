# Time Types and Nullable Fields in Go

## TL;DR

| Type | Can Be NULL/Nil? | Used In | When to Use |
|------|------------------|---------|-------------|
| `time.Time` | ❌ No | Always-present fields | `CreatedAt`, `UpdatedAt` |
| `*time.Time` | ✅ Yes (nil) | Domain entities, DTOs | `DeletedAt`, `CompletedAt`, `DueDate` |
| `sql.NullTime` | ✅ Yes (Valid: false) | Database layer (sqlc) | Generated by sqlc for nullable DB columns |

---

## The Problem: Representing "No Value"

In databases, fields can be **NULL** (no value). But Go has different ways to represent this:

```sql
-- Database: todos table
CREATE TABLE todos (
    id UUID PRIMARY KEY,
    title TEXT NOT NULL,           -- Always has value
    created_at TIMESTAMP NOT NULL,  -- Always has value
    due_date TIMESTAMP,             -- Can be NULL (optional)
    completed_at TIMESTAMP,         -- Can be NULL (optional)
    deleted_at TIMESTAMP            -- Can be NULL (optional)
);
```

How do we represent these nullable fields in Go?

---

## Part 1: The Three Time Types

### 1. `time.Time` - Always Has a Value

**Use for fields that ALWAYS exist** (never NULL in database).

```go
import "time"

type Todo struct {
    CreatedAt time.Time  // Always has value
    UpdatedAt time.Time  // Always has value
}

// Creating
todo := Todo{
    CreatedAt: time.Now(),
    UpdatedAt: time.Now(),
}

// Zero value
var t time.Time
fmt.Println(t)  // 0001-01-01 00:00:00 +0000 UTC (not useful for NULL)
```

**Characteristics:**
- ✅ Simple to use
- ✅ No nil checks needed
- ❌ Can't represent "no value" or database NULL
- ❌ Zero value is confusing (`0001-01-01`)

**When to use:**
- Fields that always have a value
- `CreatedAt`, `UpdatedAt` timestamps
- Required date fields

---

### 2. `*time.Time` - Pointer to Time (Can Be Nil)

**Use for optional fields in your domain entities and DTOs.**

```go
type Todo struct {
    CreatedAt   time.Time   // Always has value
    DueDate     *time.Time  // Optional (can be nil)
    CompletedAt *time.Time  // Optional (can be nil)
    DeletedAt   *time.Time  // Optional (can be nil)
}

// Creating with no due date
todo := Todo{
    CreatedAt: time.Now(),
    DueDate:   nil,  // No due date set
}

// Creating with due date
tomorrow := time.Now().Add(24 * time.Hour)
todoWithDue := Todo{
    CreatedAt: time.Now(),
    DueDate:   &tomorrow,  // Due tomorrow
}

// Checking if has value
if todo.DueDate != nil {
    fmt.Println("Due:", *todo.DueDate)
} else {
    fmt.Println("No due date")
}

// Safely accessing
if todo.CompletedAt != nil {
    fmt.Println("Completed:", *todo.CompletedAt)
}
```

**Characteristics:**
- ✅ Can be nil (represents NULL)
- ✅ Clean, idiomatic Go
- ✅ Works with JSON `omitempty`
- ✅ No database-specific types in domain layer
- ⚠️ Need nil checks before dereferencing

**When to use:**
- Domain entities (`domain/entity/`)
- DTOs (`internal/dto/`)
- Optional date fields
- Soft delete timestamps
- Completion timestamps

---

### 3. `sql.NullTime` - Database-Specific Nullable Time

**Use only in database layer (generated by sqlc).**

```go
import "database/sql"

type TodoDB struct {
    CreatedAt   sql.NullTime
    DueDate     sql.NullTime
    CompletedAt sql.NullTime
    DeletedAt   sql.NullTime
}

// Creating NULL value
todo := TodoDB{
    DueDate: sql.NullTime{Valid: false},  // NULL
}

// Creating with value
todo := TodoDB{
    DueDate: sql.NullTime{
        Time:  time.Now(),
        Valid: true,  // Has value
    },
}

// Checking if has value
if todo.DueDate.Valid {
    fmt.Println("Due:", todo.DueDate.Time)
} else {
    fmt.Println("No due date (NULL)")
}
```

**Characteristics:**
- ✅ Explicitly handles database NULL
- ✅ Type-safe database operations
- ✅ Generated by sqlc automatically
- ❌ Verbose (need to check `.Valid` and access `.Time`)
- ❌ Database-specific (not for domain layer)

**When to use:**
- **ONLY** in database layer (`internal/repository/sqlc/`)
- Generated by sqlc
- Direct database operations
- **Don't use in domain entities or DTOs!**

---

## Part 2: Time Types Across Layers

Your application has **three layers**, each using different time types:

### Layer 1: Domain Entities (`domain/entity/`)

**Use `time.Time` for required fields, `*time.Time` for optional.**

```go
// domain/entity/todo.go
package entity

import (
    "time"
    "github.com/google/uuid"
)

type Todo struct {
    ID          uuid.UUID
    UserID      uuid.UUID
    Title       string
    Description string
    Completed   bool
    Priority    Priority

    // Always have values
    CreatedAt   time.Time   // ← time.Time
    UpdatedAt   time.Time   // ← time.Time

    // Optional fields (can be nil)
    DueDate     *time.Time  // ← *time.Time
    CompletedAt *time.Time  // ← *time.Time
    DeletedAt   *time.Time  // ← *time.Time
}

func (t *Todo) MarkAsCompleted() {
    now := time.Now()
    t.Completed = true
    t.CompletedAt = &now  // Set pointer
    t.UpdatedAt = now
}

func (t *Todo) IsDeleted() bool {
    return t.DeletedAt != nil  // Check if nil
}
```

**Why this approach:**
- ✅ Clean domain model
- ✅ No database concerns
- ✅ Easy to work with in business logic
- ✅ Nil represents "no value"

---

### Layer 2: DTOs (`internal/dto/`)

**Use `time.Time` for required fields, `*time.Time` for optional with `omitempty`.**

```go
// internal/dto/todo_dto.go
package dto

import (
    "time"
    "github.com/google/uuid"
)

type TodoResponse struct {
    ID          uuid.UUID  `json:"id"`
    Title       string     `json:"title"`
    Description string     `json:"description"`
    Completed   bool       `json:"completed"`
    Priority    string     `json:"priority"`

    // Always in response
    CreatedAt   time.Time  `json:"created_at"`  // ← time.Time
    UpdatedAt   time.Time  `json:"updated_at"`  // ← time.Time

    // Optional fields with omitempty
    DueDate     *time.Time `json:"due_date,omitempty"`      // ← *time.Time with omitempty
    CompletedAt *time.Time `json:"completed_at,omitempty"`  // ← *time.Time with omitempty
}

// JSON output when DueDate is nil
{
    "id": "123",
    "title": "Buy milk",
    "created_at": "2024-02-03T10:30:00Z",
    "updated_at": "2024-02-03T10:30:00Z"
    // due_date is omitted because it's nil and has omitempty
}

// JSON output when DueDate has value
{
    "id": "123",
    "title": "Buy milk",
    "created_at": "2024-02-03T10:30:00Z",
    "updated_at": "2024-02-03T10:30:00Z",
    "due_date": "2024-02-04T10:30:00Z"  // ← included because it has value
}
```

**The `omitempty` tag:**
- If field is `nil`, it's **omitted** from JSON
- If field has value, it's **included** in JSON
- Only works with pointer types (`*time.Time`)

---

### Layer 3: Database Models (`internal/repository/sqlc/`)

**Use `sql.NullTime` (generated by sqlc).**

```go
// internal/repository/sqlc/models.go (GENERATED by sqlc)
package sqlc

import (
    "database/sql"
    "github.com/google/uuid"
)

type Todo struct {
    ID          uuid.UUID
    UserID      uuid.UUID
    Title       string
    Description sql.NullString
    Completed   sql.NullBool
    Priority    sql.NullString

    // All use sql.NullTime
    DueDate     sql.NullTime  // ← sql.NullTime
    CreatedAt   sql.NullTime  // ← sql.NullTime
    UpdatedAt   sql.NullTime  // ← sql.NullTime
    CompletedAt sql.NullTime  // ← sql.NullTime
    DeletedAt   sql.NullTime  // ← sql.NullTime
}
```

**Why `sql.NullTime` everywhere:**
- Generated by sqlc based on database schema
- Handles database NULL explicitly
- Type-safe database operations
- **You don't write this code** - sqlc generates it

---

## Part 3: Converting Between Types

You need helper functions to convert between domain (`*time.Time`) and database (`sql.NullTime`).

### Conversion Helpers

```go
// internal/repository/sqlc_impl/helpers.go
package sqlc_impl

import (
    "database/sql"
    "time"
)

// Convert *time.Time to sql.NullTime (domain → database)
func toNullTimePtr(t *time.Time) sql.NullTime {
    if t == nil {
        return sql.NullTime{Valid: false}  // NULL in database
    }
    return sql.NullTime{Time: *t, Valid: true}  // Has value
}

// Convert time.Time to sql.NullTime (always has value)
func toNullTime(t time.Time) sql.NullTime {
    return sql.NullTime{Time: t, Valid: true}
}

// Convert sql.NullTime to *time.Time (database → domain)
func fromNullTimePtr(nt sql.NullTime) *time.Time {
    if !nt.Valid {
        return nil  // NULL becomes nil
    }
    return &nt.Time  // Value becomes pointer
}

// Convert sql.NullTime to time.Time (assuming always valid)
func fromNullTime(nt sql.NullTime) time.Time {
    return nt.Time
}
```

---

### Using Converters in Repository

```go
// internal/repository/sqlc_impl/todo_repository.go
package sqlc_impl

import (
    "context"
    "todo_app/domain/entity"
    "todo_app/internal/repository/sqlc"
)

// Saving to database (domain entity → database model)
func (r *todoRepository) Create(ctx context.Context, todo *entity.Todo) error {
    params := sqlc.CreateTodoParams{
        ID:     todo.ID,
        UserID: todo.UserID,
        Title:  todo.Title,

        // Always-present fields
        CreatedAt: toNullTime(todo.CreatedAt),  // time.Time → sql.NullTime
        UpdatedAt: toNullTime(todo.UpdatedAt),  // time.Time → sql.NullTime

        // Optional fields
        DueDate:     toNullTimePtr(todo.DueDate),      // *time.Time → sql.NullTime
        CompletedAt: toNullTimePtr(todo.CompletedAt),  // *time.Time → sql.NullTime
        DeletedAt:   toNullTimePtr(todo.DeletedAt),    // *time.Time → sql.NullTime
    }

    return r.queries.CreateTodo(ctx, params)
}

// Loading from database (database model → domain entity)
func (r *todoRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.Todo, error) {
    dbTodo, err := r.queries.GetTodoByID(ctx, id)
    if err != nil {
        return nil, err
    }

    return &entity.Todo{
        ID:     dbTodo.ID,
        UserID: dbTodo.UserID,
        Title:  dbTodo.Title,

        // Always-present fields
        CreatedAt: fromNullTime(dbTodo.CreatedAt),  // sql.NullTime → time.Time
        UpdatedAt: fromNullTime(dbTodo.UpdatedAt),  // sql.NullTime → time.Time

        // Optional fields
        DueDate:     fromNullTimePtr(dbTodo.DueDate),      // sql.NullTime → *time.Time
        CompletedAt: fromNullTimePtr(dbTodo.CompletedAt),  // sql.NullTime → *time.Time
        DeletedAt:   fromNullTimePtr(dbTodo.DeletedAt),    // sql.NullTime → *time.Time
    }, nil
}
```

---

## Part 4: Practical Examples

### Example 1: Creating a Todo Without Due Date

```go
// Domain layer
todo := entity.NewTodo(userID, "Buy milk", "From store", entity.PriorityMedium, nil)
// DueDate is nil

// DTO (JSON response)
{
    "id": "550e8400-...",
    "title": "Buy milk",
    "created_at": "2024-02-03T10:30:00Z",
    "updated_at": "2024-02-03T10:30:00Z"
    // due_date omitted because nil + omitempty
}

// Database
INSERT INTO todos (id, title, due_date, ...)
VALUES ('550e8400-...', 'Buy milk', NULL, ...)
--                                    ↑ NULL in database
```

---

### Example 2: Creating a Todo With Due Date

```go
// Domain layer
tomorrow := time.Now().Add(24 * time.Hour)
todo := entity.NewTodo(userID, "Buy milk", "From store", entity.PriorityMedium, &tomorrow)
// DueDate is pointer to tomorrow

// DTO (JSON response)
{
    "id": "550e8400-...",
    "title": "Buy milk",
    "created_at": "2024-02-03T10:30:00Z",
    "updated_at": "2024-02-03T10:30:00Z",
    "due_date": "2024-02-04T10:30:00Z"  // ← included because has value
}

// Database
INSERT INTO todos (id, title, due_date, ...)
VALUES ('550e8400-...', 'Buy milk', '2024-02-04 10:30:00', ...)
--                                    ↑ actual timestamp
```

---

### Example 3: Completing a Todo

```go
// Domain layer
todo.MarkAsCompleted()
// Sets CompletedAt to current time

func (t *Todo) MarkAsCompleted() {
    now := time.Now()
    t.Completed = true
    t.CompletedAt = &now  // Set pointer to current time
    t.UpdatedAt = now
}

// DTO (JSON response)
{
    "id": "550e8400-...",
    "completed": true,
    "completed_at": "2024-02-03T15:45:00Z"  // ← now included
}

// Database
UPDATE todos
SET completed = true, completed_at = '2024-02-03 15:45:00'
WHERE id = '550e8400-...'
```

---

### Example 4: Soft Deleting a Todo

```go
// Domain layer
now := time.Now()
todo.DeletedAt = &now  // Mark as deleted

// Database
UPDATE todos
SET deleted_at = '2024-02-03 16:00:00'
WHERE id = '550e8400-...'

// Checking if deleted
if todo.IsDeleted() {  // Checks if DeletedAt != nil
    fmt.Println("Todo is deleted")
}
```

---

## Part 5: JSON Serialization with `omitempty`

### What is `omitempty`?

The `omitempty` tag tells Go to **omit the field from JSON if it's empty**.

```go
type TodoResponse struct {
    Title       string     `json:"title"`                   // Always included
    DueDate     *time.Time `json:"due_date"`                // Included even if nil (shows as null)
    CompletedAt *time.Time `json:"completed_at,omitempty"`  // Omitted if nil
}
```

### With `omitempty`

```go
todo := TodoResponse{
    Title:       "Buy milk",
    CompletedAt: nil,  // Will be omitted
}

// JSON output:
{
    "title": "Buy milk"
    // completed_at is completely omitted (not even "completed_at": null)
}
```

### Without `omitempty`

```go
type TodoResponse struct {
    Title       string     `json:"title"`
    CompletedAt *time.Time `json:"completed_at"`  // No omitempty
}

todo := TodoResponse{
    Title:       "Buy milk",
    CompletedAt: nil,
}

// JSON output:
{
    "title": "Buy milk",
    "completed_at": null  // ← Shows as null
}
```

### When to Use `omitempty`

| Use Case | Use `omitempty`? | Reason |
|----------|------------------|--------|
| Optional fields that might not exist | ✅ Yes | Cleaner JSON, smaller payload |
| Fields that should show `null` when empty | ❌ No | Client needs to know field exists but is null |
| Required fields | ❌ No | Should always be present |

---

## Part 6: Common Patterns

### Pattern 1: Safe Dereferencing

```go
// ❌ BAD: Can panic if nil
fmt.Println(*todo.DueDate)  // Panic if nil!

// ✅ GOOD: Check before dereferencing
if todo.DueDate != nil {
    fmt.Println(*todo.DueDate)
}

// ✅ GOOD: Helper function
func formatDueDate(dueDate *time.Time) string {
    if dueDate == nil {
        return "No due date"
    }
    return dueDate.Format("2006-01-02")
}
```

---

### Pattern 2: Setting Optional Fields

```go
// Creating new value
now := time.Now()
todo.CompletedAt = &now

// Clearing value
todo.CompletedAt = nil

// Conditional setting
if shouldSetDueDate {
    tomorrow := time.Now().Add(24 * time.Hour)
    todo.DueDate = &tomorrow
}
```

---

### Pattern 3: Comparing Times

```go
// ❌ BAD: Can panic
if *todo.DueDate.Before(time.Now()) {
    // Panic if DueDate is nil!
}

// ✅ GOOD: Safe comparison
if todo.DueDate != nil && todo.DueDate.Before(time.Now()) {
    fmt.Println("Todo is overdue")
}
```

---

## Part 7: Decision Tree

**"Which time type should I use?"**

```
Is the field in database layer (sqlc-generated)?
├─ YES → Use sql.NullTime (generated automatically)
└─ NO → Continue...

Does the field always have a value?
├─ YES → Use time.Time
│        Example: CreatedAt, UpdatedAt
└─ NO → Use *time.Time
         Example: DueDate, CompletedAt, DeletedAt
```

---

## Summary

### Quick Reference

| Type | Syntax | Nil/NULL | Use In | Example Fields |
|------|--------|----------|--------|----------------|
| `time.Time` | `time.Time` | ❌ No | Always-present | `CreatedAt`, `UpdatedAt` |
| `*time.Time` | `*time.Time` | ✅ Yes (nil) | Optional | `DueDate`, `CompletedAt`, `DeletedAt` |
| `sql.NullTime` | `sql.NullTime` | ✅ Yes (Valid: false) | Database only | All time fields in sqlc models |

### Best Practices

1. **Domain Entities & DTOs**: Use `*time.Time` for optional fields
2. **Database Models**: Use `sql.NullTime` (auto-generated by sqlc)
3. **JSON DTOs**: Add `omitempty` to optional fields
4. **Always nil-check**: Before dereferencing `*time.Time`
5. **Use converters**: Between `*time.Time` and `sql.NullTime`

### Your Current Architecture (Correct! ✅)

```go
// Domain Entity
type Todo struct {
    CreatedAt   time.Time   // Always has value
    DueDate     *time.Time  // Optional
}

// DTO
type TodoResponse struct {
    CreatedAt   time.Time  `json:"created_at"`
    DueDate     *time.Time `json:"due_date,omitempty"`  // Omitted if nil
}

// Database Model (sqlc-generated)
type Todo struct {
    CreatedAt   sql.NullTime
    DueDate     sql.NullTime
}
```

**This is the idiomatic Go way!** ✅
