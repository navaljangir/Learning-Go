# Repository Pattern, Interfaces & Why We Define Structs Multiple Times

Coming from Node.js, Go's architecture patterns might seem repetitive at first. Let's break down **why** we define similar-looking structs in different places and **how** interfaces work.

---

## Table of Contents

1. [Why Define Structs Multiple Times?](#why-define-structs-multiple-times)
2. [Understanding Interface Implementation in Go](#understanding-interface-implementation-in-go)
3. [What is sqlc_impl?](#what-is-sqlc_impl)
4. [What is gorm_impl?](#what-is-gorm_impl)
5. [The Complete Flow](#the-complete-flow)
6. [Node.js vs Go Comparison](#nodejs-vs-go-comparison)

---

## Why Define Structs Multiple Times?

### The Three Layers of Data Representation

In your codebase, you'll see the **same data** represented in **three different ways**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     API/Handler Layer                        â”‚
â”‚  UserResponse struct (what users see)                       â”‚
â”‚  - No passwords                                              â”‚
â”‚  - No internal fields                                        â”‚
â”‚  - JSON formatted                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Domain/Entity Layer                      â”‚
â”‚  entity.User struct (business logic)                        â”‚
â”‚  - Clean, simple types (string, time.Time)                  â”‚
â”‚  - Has methods (business logic)                             â”‚
â”‚  - Database-agnostic                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Database Layer                           â”‚
â”‚  sqlc.User struct (database representation)                 â”‚
â”‚  - sql.NullString, sql.NullTime                             â”‚
â”‚  - Matches database schema exactly                          â”‚
â”‚  - Generated by sqlc                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Example from Your Codebase

#### 1. **API Response Struct** (in handlers/DTOs)

```go
type UserResponse struct {
    ID        uuid.UUID `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    FullName  string    `json:"full_name"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    
    // NO PasswordHash â† Security! Don't expose
    // NO DeletedAt â† Don't expose internal details
}
```

**Purpose**: This is what your API returns to clients. It's a "view" of the data that:
- **Hides sensitive fields** (no password hash)
- **Hides internal implementation** (no deleted_at)
- **Uses clean types** (string instead of sql.NullString)

---

#### 2. **Domain Entity** (in `domain/entity/user.go`)

```go
package entity

type User struct {
    ID           uuid.UUID
    Username     string
    Email        string
    PasswordHash string      // â† Has password for authentication
    FullName     string      // â† Clean string (not sql.NullString)
    CreatedAt    time.Time   // â† Clean time.Time (not sql.NullTime)
    UpdatedAt    time.Time
    DeletedAt    *time.Time  // â† Pointer for optional values
}

// Business logic methods
func (u *User) IsDeleted() bool {
    return u.DeletedAt != nil
}
```

**Purpose**: This represents your **business domain**. It:
- **Contains all fields** (including sensitive ones for internal use)
- **Has business logic methods** (`IsDeleted()`, `Validate()`, etc.)
- **Uses clean Go types** (string, time.Time, not database-specific types)
- **Is database-agnostic** (doesn't know if you use Postgres, MySQL, or MongoDB)

---

#### 3. **Database Model** (in `internal/repository/sqlc/models.go` - Generated by sqlc)

```go
// Code generated by sqlc. DO NOT EDIT.
package sqlc

type User struct {
    ID           uuid.UUID      `json:"id"`
    Username     string         `json:"username"`
    Email        string         `json:"email"`
    PasswordHash string         `json:"password_hash"`
    FullName     sql.NullString `json:"full_name"` // â† Database NULL handling
    CreatedAt    sql.NullTime   `json:"created_at"`
    UpdatedAt    sql.NullTime   `json:"updated_at"`
    DeletedAt    sql.NullTime   `json:"deleted_at"`
}
```

**Purpose**: This represents **exactly how data is stored in the database**. It:
- **Uses database types** (`sql.NullString`, `sql.NullTime` for nullable columns)
- **Matches database schema 1:1** (every column has a field)
- **Is auto-generated** by sqlc from your SQL queries
- **Has no business logic** (just data structure)

---

### Why Not Use One Struct Everywhere?

**JavaScript/Node.js Perspective**: You might be thinking, "In Node.js, I just use one object for everything!"

```javascript
// Node.js - Same object everywhere
const user = {
  id: '123',
  username: 'john',
  email: 'john@example.com',
  passwordHash: '$2a$10...',  // Oops, exposed to client!
  createdAt: new Date()
};

// Return to API (need to manually delete sensitive fields)
delete user.passwordHash;
return user;
```

**Problems with One Struct**:

| Problem | Example |
|---------|---------|
| **Security Risk** | Accidentally expose password hash in API response |
| **Tight Coupling** | Change DB schema â†’ breaks API contracts |
| **Messy Types** | API handlers have to deal with `sql.NullString` |
| **No Separation** | Business logic mixed with database concerns |

**Go's Solution**: **Separation of Concerns** with multiple structs:

```go
// Database layer (sqlc.User) 
    â†“ Convert
// Domain layer (entity.User) - Business logic here
    â†“ Convert
// API layer (UserResponse) - Clean, safe response
```

---

## Understanding Interface Implementation in Go

### Your Question:

> "Can you explain this? It returns `repository.TodoRepository` from the domain/repo, so there is no type error. `&todoRepository`?"

```go
func NewTodoRepository(db *sql.DB) repository.TodoRepository {
    return &todoRepository{
        db:      db,
        queries: sqlc.New(db),
    }
}
```

### How Go Interfaces Work (Different from JavaScript!)

#### In JavaScript/TypeScript:

```typescript
// TypeScript - Explicit implementation
interface TodoRepository {
  create(todo: Todo): Promise<void>;
}

class TodoRepositoryImpl implements TodoRepository {  // â† Must declare "implements"
  async create(todo: Todo): Promise<void> {
    // implementation
  }
}
```

#### In Go: **Implicit Interface Satisfaction** ğŸ¯

```go
// 1. Define interface in domain layer (the contract)
// File: domain/repository/todo_repository.go
package repository

type TodoRepository interface {
    Create(ctx context.Context, todo *entity.Todo) error
    FindByID(ctx context.Context, id uuid.UUID) (*entity.Todo, error)
    Update(ctx context.Context, todo *entity.Todo) error
    Delete(ctx context.Context, id uuid.UUID) error
}
```

```go
// 2. Define implementation in infrastructure layer
// File: internal/repository/sqlc_impl/todo_repository.go
package sqlc_impl

// Private struct (lowercase 't' in todoRepository)
type todoRepository struct {
    db      *sql.DB
    queries *sqlc.Queries
}

// These methods make todoRepository satisfy TodoRepository interface
// No "implements" keyword needed!
func (r *todoRepository) Create(ctx context.Context, todo *entity.Todo) error {
    // implementation using sqlc
}

func (r *todoRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.Todo, error) {
    // implementation using sqlc
}

func (r *todoRepository) Update(ctx context.Context, todo *entity.Todo) error {
    // implementation using sqlc
}

func (r *todoRepository) Delete(ctx context.Context, id uuid.UUID) error {
    // implementation using sqlc
}
```

```go
// 3. Constructor returns the interface type
func NewTodoRepository(db *sql.DB) repository.TodoRepository {
    return &todoRepository{  // â† Returns concrete type
        db:      db,         //    but typed as interface
        queries: sqlc.New(db),
    }
}
```

### Why This Works:

**Go's Rule**: If a type has **all the methods** that an interface requires, it **automatically satisfies** that interface.

```go
// âœ… todoRepository has these methods:
// - Create(ctx, todo) error
// - FindByID(ctx, id) (*entity.Todo, error)
// - Update(ctx, todo) error
// - Delete(ctx, id) error

// âœ… repository.TodoRepository requires these methods:
// - Create(ctx, todo) error
// - FindByID(ctx, id) (*entity.Todo, error)
// - Update(ctx, todo) error
// - Delete(ctx, id) error

// âœ… Match! todoRepository satisfies TodoRepository
```

### Visual Explanation:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  repository.TodoRepository (interface in domain)        â”‚
â”‚  - Create(...)                                          â”‚
â”‚  - FindByID(...)                                        â”‚
â”‚  - Update(...)                                          â”‚
â”‚  - Delete(...)                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†‘
                        â”‚ Satisfies (implicitly)
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  todoRepository (concrete struct in sqlc_impl)          â”‚
â”‚  + db: *sql.DB                                          â”‚
â”‚  + queries: *sqlc.Queries                               â”‚
â”‚  + Create(...)   â† Implements interface method          â”‚
â”‚  + FindByID(...) â† Implements interface method          â”‚
â”‚  + Update(...)   â† Implements interface method          â”‚
â”‚  + Delete(...)   â† Implements interface method          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Return `&todoRepository` and Not `todoRepository`?

```go
return &todoRepository{...}  // â† Pointer
```

**Reason**: Methods are defined with **pointer receiver**:

```go
func (r *todoRepository) Create(...) error {  // â† *todoRepository (pointer)
    return r.queries.CreateTodo(...)
}
```

If you returned `todoRepository` (value), Go would complain:

```
âŒ todoRepository does not implement repository.TodoRepository
   (Create method has pointer receiver)
```

**Rule of Thumb**: If your methods modify the struct **or** if the struct is large, use pointer receivers (`*todoRepository`).

---

## What is sqlc_impl?

### Your Question:

> "Ok so this sqlc_impl is generated by sqlc-generate right?"

**Answer**: **No, it's NOT generated!** Let's clarify what sqlc generates:

### What sqlc Generates

When you run `sqlc generate`, it reads your SQL queries and generates:

```
internal/repository/sqlc/          â† Generated by sqlc
â”œâ”€â”€ db.go                          â† Database connection helpers
â”œâ”€â”€ models.go                      â† sqlc.User, sqlc.Todo (DB structs)
â”œâ”€â”€ querier.go                     â† Interface for all queries
â”œâ”€â”€ users.sql.go                   â† User query functions
â””â”€â”€ todos.sql.go                   â† Todo query functions
```

**Example of generated code** (`todos.sql.go`):

```go
// Code generated by sqlc. DO NOT EDIT.
package sqlc

func (q *Queries) CreateTodo(ctx context.Context, params CreateTodoParams) error {
    const sql = `INSERT INTO todos (id, user_id, title, ...) VALUES ($1, $2, $3, ...)`
    _, err := q.db.ExecContext(ctx, sql, params.ID, params.UserID, ...)
    return err
}

func (q *Queries) GetTodoByID(ctx context.Context, id uuid.UUID) (Todo, error) {
    const sql = `SELECT * FROM todos WHERE id = $1`
    // ... implementation
}
```

### What You Write (sqlc_impl)

**You write** the `sqlc_impl` package to:
1. **Implement your domain interfaces** using the sqlc-generated code
2. **Convert between layers** (sqlc.Todo â†” entity.Todo)
3. **Add error handling and business logic**

```
internal/repository/sqlc_impl/     â† You write this!
â”œâ”€â”€ todo_repository.go             â† Implements domain interface
â””â”€â”€ user_repository.go             â† Implements domain interface
```

**Example you wrote** (`sqlc_impl/todo_repository.go`):

```go
package sqlc_impl

// You define this struct
type todoRepository struct {
    db      *sql.DB
    queries *sqlc.Queries  // â† Uses sqlc-generated code
}

// You write this constructor
func NewTodoRepository(db *sql.DB) repository.TodoRepository {
    return &todoRepository{
        db:      db,
        queries: sqlc.New(db),  // â† sqlc.New is generated
    }
}

// You write this implementation
func (r *todoRepository) Create(ctx context.Context, todo *entity.Todo) error {
    // Convert entity.Todo â†’ sqlc.CreateTodoParams
    params := sqlc.CreateTodoParams{
        ID:          todo.ID,
        UserID:      todo.UserID,
        Title:       todo.Title,
        Description: toNullString(todo.Description),
        // ...
    }
    
    // Use sqlc-generated function
    return r.queries.CreateTodo(ctx, params)
}

// You write this converter
func sqlcTodoToEntity(t sqlc.Todo) *entity.Todo {
    return &entity.Todo{
        ID:          t.ID,
        UserID:      t.UserID,
        Title:       t.Title,
        Description: fromNullString(t.Description),
        // ...
    }
}
```

### The Relationship:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Code: sqlc_impl/todo_repository.go                 â”‚
â”‚                                                           â”‚
â”‚  - Implements domain/repository interface                â”‚
â”‚  - Converts entity.Todo â†” sqlc.Todo                      â”‚
â”‚  - Adds business logic                                   â”‚
â”‚                                                           â”‚
â”‚  Uses â†“                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generated: sqlc/todos.sql.go                            â”‚
â”‚                                                           â”‚
â”‚  - CreateTodo(ctx, params) error                         â”‚
â”‚  - GetTodoByID(ctx, id) (sqlc.Todo, error)              â”‚
â”‚  - UpdateTodo(ctx, params) error                         â”‚
â”‚                                                           â”‚
â”‚  (Generated by: sqlc generate)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What is gorm_impl?

### Your Question:

> "userRepo := gorm_impl.NewUserRepository(db) - what is this gorm_implementation?"

`gorm_impl` would be **another implementation** of the same repository interface, but using **GORM** (an ORM) instead of sqlc.

### Multiple Implementations of the Same Interface

Remember, **interfaces define behavior, not implementation**. You can have multiple implementations:

```
domain/repository/user_repository.go (interface)
                â†‘
                â”‚ Implements
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                 â”‚
   sqlc_impl       gorm_impl
  (uses SQL)     (uses ORM)
```

### Example:

#### 1. **Domain Interface** (same for all implementations):

```go
// domain/repository/user_repository.go
package repository

type UserRepository interface {
    Create(ctx context.Context, user *entity.User) error
    FindByID(ctx context.Context, id uuid.UUID) (*entity.User, error)
    FindByUsername(ctx context.Context, username string) (*entity.User, error)
}
```

#### 2. **sqlc Implementation** (what you already have):

```go
// internal/repository/sqlc_impl/user_repository.go
package sqlc_impl

type userRepository struct {
    db      *sql.DB
    queries *sqlc.Queries  // â† Uses generated sqlc code
}

func NewUserRepository(db *sql.DB) repository.UserRepository {
    return &userRepository{
        db:      db,
        queries: sqlc.New(db),
    }
}

func (r *userRepository) Create(ctx context.Context, user *entity.User) error {
    // Use sqlc-generated CreateUser function
    params := sqlc.CreateUserParams{ /* ... */ }
    return r.queries.CreateUser(ctx, params)
}
```

#### 3. **GORM Implementation** (alternative):

```go
// internal/repository/gorm_impl/user_repository.go
package gorm_impl

import "gorm.io/gorm"

type userRepository struct {
    db *gorm.DB  // â† Uses GORM instead of sql.DB
}

func NewUserRepository(db *gorm.DB) repository.UserRepository {
    return &userRepository{db: db}
}

func (r *userRepository) Create(ctx context.Context, user *entity.User) error {
    // Use GORM's Create method
    return r.db.WithContext(ctx).Create(user).Error
}

func (r *userRepository) FindByID(ctx context.Context, id uuid.UUID) (*entity.User, error) {
    var user entity.User
    err := r.db.WithContext(ctx).First(&user, "id = ?", id).Error
    return &user, err
}
```

### Why Have Multiple Implementations?

| Scenario | Example |
|----------|---------|
| **Testing** | `memory_impl` for unit tests (no real database) |
| **Migration** | Switch from GORM to sqlc without changing business logic |
| **Different Databases** | `postgres_impl`, `mysql_impl`, `mongodb_impl` |
| **Caching** | `cache_impl` wraps another implementation |

### How to Use Different Implementations:

```go
// main.go

// Choose implementation at runtime
func main() {
    db, _ := sql.Open("postgres", dsn)
    
    // Option 1: Use sqlc implementation
    userRepo := sqlc_impl.NewUserRepository(db)
    
    // Option 2: Use GORM implementation (if you had it)
    // gormDB, _ := gorm.Open(...)
    // userRepo := gorm_impl.NewUserRepository(gormDB)
    
    // Option 3: Use in-memory implementation for testing
    // userRepo := memory_impl.NewUserRepository()
    
    // Rest of your code works the same!
    userService := service.NewUserService(userRepo)
    // ...
}
```

**Key Point**: Because all implementations satisfy `repository.UserRepository`, your **business logic doesn't change** when you swap implementations!

---

## The Complete Flow

Let's trace a request from API to database and back:

### Request: `POST /todos` (Create a new todo)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. API Handler (handlers/todo_handler.go)                   â”‚
â”‚                                                              â”‚
â”‚    Receives JSON:                                            â”‚
â”‚    {                                                         â”‚
â”‚      "title": "Buy milk",                                   â”‚
â”‚      "description": "From store A",                         â”‚
â”‚      "priority": "high"                                     â”‚
â”‚    }                                                         â”‚
â”‚                                                              â”‚
â”‚    Validates input                                           â”‚
â”‚    Creates entity.Todo                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Service Layer (services/todo_service.go)                 â”‚
â”‚                                                              â”‚
â”‚    Calls: todoRepo.Create(ctx, todo)                        â”‚
â”‚                                                              â”‚
â”‚    Works with: entity.Todo (domain entity)                  â”‚
â”‚    - Business logic here                                    â”‚
â”‚    - Validation                                             â”‚
â”‚    - Authorization                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Repository Interface (domain/repository/todo_repo.go)    â”‚
â”‚                                                              â”‚
â”‚    type TodoRepository interface {                          â”‚
â”‚        Create(ctx, todo) error                              â”‚
â”‚    }                                                         â”‚
â”‚                                                              â”‚
â”‚    (Just a contract, no implementation)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Repository Implementation (sqlc_impl/todo_repository.go) â”‚
â”‚                                                              â”‚
â”‚    func (r *todoRepository) Create(ctx, todo) error {       â”‚
â”‚        // Convert entity.Todo â†’ sqlc.CreateTodoParams       â”‚
â”‚        params := sqlc.CreateTodoParams{                     â”‚
â”‚            ID:    todo.ID,                                  â”‚
â”‚            Title: todo.Title,                               â”‚
â”‚            // ...                                           â”‚
â”‚        }                                                     â”‚
â”‚                                                              â”‚
â”‚        // Call sqlc-generated function                      â”‚
â”‚        return r.queries.CreateTodo(ctx, params)             â”‚
â”‚    }                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. sqlc Generated Code (sqlc/todos.sql.go)                  â”‚
â”‚                                                              â”‚
â”‚    func (q *Queries) CreateTodo(ctx, params) error {        â”‚
â”‚        const query = `                                       â”‚
â”‚            INSERT INTO todos (id, title, ...)               â”‚
â”‚            VALUES ($1, $2, ...)                             â”‚
â”‚        `                                                     â”‚
â”‚        _, err := q.db.ExecContext(ctx, query, params...)    â”‚
â”‚        return err                                            â”‚
â”‚    }                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Database (PostgreSQL)                                     â”‚
â”‚                                                              â”‚
â”‚    INSERT INTO todos ...                                     â”‚
â”‚    Returns: Success/Error                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Response: Database â†’ API

```
Database
  â†“
sqlc.Todo (sql.NullString, sql.NullTime)
  â†“ Convert (sqlcTodoToEntity function)
entity.Todo (string, time.Time, with methods)
  â†“ Service returns
Handler
  â†“ Convert (entityToResponse function)
TodoResponse (clean JSON, no sensitive data)
  â†“
JSON Response to Client
```

---

## Node.js vs Go Comparison

### Node.js/TypeScript Approach:

```typescript
// One interface, one class
interface TodoRepository {
  create(todo: Todo): Promise<void>;
}

class TodoRepositoryImpl implements TodoRepository {
  constructor(private db: Database) {}
  
  async create(todo: Todo): Promise<void> {
    // Same object goes to DB
    await this.db.insert('todos', todo);
  }
}

// Same Todo interface everywhere
interface Todo {
  id: string;
  title: string;
  completed: boolean;
}

// Use everywhere
const handler = (req, res) => {
  const todo: Todo = req.body;
  await todoRepo.create(todo);
  res.json(todo);  // Same object returned
};
```

**Pros**: Simple, less code
**Cons**: No type safety between layers, easy to expose sensitive data

---

### Go Approach:

```go
// 1. Domain interface (contract)
type TodoRepository interface {
    Create(ctx context.Context, todo *entity.Todo) error
}

// 2. Implementation (hidden)
type todoRepository struct {
    db      *sql.DB
    queries *sqlc.Queries
}

func (r *todoRepository) Create(ctx context.Context, todo *entity.Todo) error {
    // Convert entity â†’ DB params
    params := sqlc.CreateTodoParams{...}
    return r.queries.CreateTodo(ctx, params)
}

// 3. Multiple structs for different layers
// entity.Todo (domain)
// sqlc.Todo (database)
// TodoResponse (API)

// 4. Use in handler
func (h *TodoHandler) CreateTodo(w http.ResponseWriter, r *http.Request) {
    // Parse request â†’ entity.Todo
    todo := parseTodo(r)
    
    // Save via repository
    h.todoService.Create(ctx, todo)
    
    // Convert â†’ TodoResponse
    response := todoToResponse(todo)
    json.NewEncoder(w).Encode(response)
}
```

**Pros**: Type safety, clear boundaries, testable, swappable implementations
**Cons**: More code, more files, steeper learning curve

---

## Summary

### 1. **Why Multiple Structs?**

| Struct | Purpose | Location |
|--------|---------|----------|
| `UserResponse` | API responses, no sensitive data | `handlers/` or `dto/` |
| `entity.User` | Business logic, domain rules | `domain/entity/` |
| `sqlc.User` | Database representation, NULL handling | `internal/repository/sqlc/` (generated) |

**Reason**: **Separation of concerns** - each layer has its own representation.

---

### 2. **How Interfaces Work**

```go
// Interface (domain/repository)
type TodoRepository interface {
    Create(...) error
}

// Implementation (sqlc_impl)
type todoRepository struct { ... }

func (r *todoRepository) Create(...) error { ... }  // â† Satisfies interface

// Constructor
func NewTodoRepository(db *sql.DB) repository.TodoRepository {
    return &todoRepository{...}  // â† Returns concrete type as interface
}
```

**Key**: Go uses **implicit interface satisfaction**. If a type has all methods, it implements the interface automatically.

---

### 3. **sqlc_impl vs Generated Code**

| What | Who Creates | Purpose |
|------|-------------|---------|
| `internal/repository/sqlc/` | **sqlc generates** | Type-safe SQL queries |
| `internal/repository/sqlc_impl/` | **You write** | Implements domain interfaces using sqlc |

---

### 4. **gorm_impl**

**Alternative implementation** of the same interface using GORM ORM instead of sqlc. Lets you swap implementations without changing business logic.

---

## Next Steps

1. **Practice**: Create a `memory_impl` for testing (no database)
2. **Read**: Look at how `sqlcTodoToEntity` converts between layers
3. **Experiment**: Try adding a new method to `TodoRepository` and implement it in `sqlc_impl`

---

## Quick Reference

```bash
# Generate sqlc code
sqlc generate

# Your code structure
domain/
  repository/          # Interfaces (contracts)
internal/
  repository/
    sqlc/              # Generated by sqlc
    sqlc_impl/         # Your implementations using sqlc
    gorm_impl/         # (Optional) Your implementations using GORM
```

**Remember**: 
- **Interfaces** = What (contract)
- **Implementations** = How (concrete code)
- **Multiple structs** = Separation of concerns (security + maintainability)
